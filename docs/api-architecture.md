API Architecture – GlobalNet Monitor (GNM)

Author: Soufianne Nassibi
Role: Technical Lead – Linux Systems & Large-Scale Monitoring Architect
Website: https://soufianne-nassibi.com

Live Demo: https://gnmradar.ovh/

License: GNU GPL v3.0 (API component only)

1. Purpose

The API layer exposes monitoring telemetry generated by the Collector.

It does not execute checks.

It does not implement alerting.

It does not include visualization.

It is a structured data exposure backend.

The API enables:

Latest status retrieval

Time-series extraction

Target metadata exposure

Region-based filtering

Aggregated health analysis

2. Architectural Role

Logical architecture:

Collector → MySQL → API → External Consumers


The API sits between database storage and any consumer (dashboard, automation, analytics).

It is stateless.

All state resides in the database.

3. Technology Stack

Python 3.8+

FastAPI

PyMySQL

Uvicorn (ASGI server)

Optional: Prometheus instrumentation

Optional: SlowAPI (rate limiting)

4. Design Principles

Stateless HTTP layer

Deterministic query behavior

No business logic duplication

Explicit filtering parameters

JSON-native responses

Pagination support

Input validation via FastAPI models

5. Endpoint Overview
5.1 Health Endpoint
GET /health


Purpose:

Confirms configuration loading

Confirms DB configuration availability

Response:

{
  "status": "ok"
}

5.2 Latest Measurements
GET /api/last


Parameters:

limit (max 500)

offset

region (optional)

project_id (optional)

Returns:

Most recent measurements

Ordered by timestamp DESC

5.3 Latest By Target
GET /api/last-by-target


Returns:

Most recent measurement per target_id

Used for dashboards.

5.4 Time-Series Extraction
GET /api/timeseries


Parameters:

target_id

from_ts

to_ts

limit

region (optional)

Returns ordered telemetry window.

5.5 Target Metadata
GET /api/meta/targets


Returns:

List of configured targets

Host associations

Service types

Used by dashboards to dynamically build layouts.

6. Query Strategy

API uses:

Indexed queries

LIMIT constraints

Optional region filtering

Aggregation via GROUP BY where required

No N+1 queries.

All heavy queries must use indexed fields:

ts

target_id

region

project_id

7. Pagination Model

Endpoints supporting large result sets implement:

limit (max 500)

offset

Prevents memory exhaustion and unbounded responses.

8. JSON Metadata Handling

The meta_json column is stored as JSON.

The API:

Parses JSON safely

Returns normalized Python dict

Handles malformed JSON gracefully

Helper function:

parse_meta_json(rows)


Prevents repeated parsing code.

9. Performance Considerations

Expected workload:

50–100 requests per second (moderate scale)

Optimizations:

DB connection pooling

Indexed queries

Query limits

JSON parsing normalization

Optional caching on metadata endpoints

10. Optional Caching Strategy

For endpoints such as:

/api/meta/targets


Recommended:

TTL cache (60 seconds)

functools.lru_cache

Thread-safe caching

Prevents repeated file reads.

11. Optional Rate Limiting

Recommended:

60 requests/min per IP for standard endpoints

10 requests/min per IP for heavy endpoints

Implemented via:

slowapi


Prevents abuse and resource exhaustion.

12. Prometheus Instrumentation (Optional)

If enabled:

/metrics


Exports:

HTTP request count

Request duration

Error rate

DB query time

This enables API observability without modifying core logic.

13. Error Handling Model

API uses:

HTTPException

400 for bad input

404 for missing target

429 for rate limit exceeded

503 for configuration or DB failure

Errors are explicit and descriptive.

14. Security Considerations

API does not include:

Authentication

Authorization

RBAC

Recommended deployment:

Nginx reverse proxy

TLS termination

IP filtering

Firewall restrictions

Optional API token layer (external)

15. Deployment Model

Recommended production deployment:

uvicorn api:app --host 0.0.0.0 --port 8000 --workers 2


For production scale:

Use gunicorn with uvicorn workers

Place behind reverse proxy

Enable keepalive

16. API Constraints

API does not:

Modify monitoring data

Execute checks

Perform alerting

Persist configuration

Support WebSocket streaming

Support SNMP ingestion

It is intentionally a read-only telemetry exposure layer.

17. Scaling Strategy

Horizontal scaling:

Multiple API instances

Shared DB

Load balancer in front

Vertical scaling:

Increase DB capacity

Add read replica

Optimize indexes

18. Architectural Positioning

The API is:

A deterministic telemetry interface

A read-only data service

A monitoring data backend

A dashboard integration layer

It is not:

A monitoring engine

A metrics scraper

A log aggregation system

A SaaS application

Author

Soufianne Nassibi
Technical Lead – Linux Systems & Monitoring Architect

https://soufianne-nassibi.com

https://gnmradar.ovh

© Soufianne Nassibi – GlobalNet Monitor (GNM)
